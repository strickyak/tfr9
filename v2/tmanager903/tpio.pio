; tpio.pio -- for the TFR/901 -- strick
; This is the King's PIO assembly language code.
;
; SPDX-License-Identifier: MIT

;#########################.define public EBAR    1
;#########################.define public QBAR    2
;#########################.define public MODE0   0 ; (0 << 2)
;#########################.define public MODE1   4 ; (1 << 2)
;#########################.define public MODE2   8 ; (2 << 2)
;#########################.define public MODE3  12 ; (3 << 2)
;#########################.define public MODE4  16 ; (4 << 2)
;#########################.define public MODE5  20 ; (5 << 2)
;#########################.define public MODE6  24 ; (6 << 2)
;#########################.define public MODE7  28 ; (7 << 2)

; E = 1
; Q = 2
; Not RecvAddress = 4
; Not RecvData = 8
; Not SendData = 16 + 8

; Phase1 : 0
; Phase2 : 2
; Phase3 : 3
; Phase4 : 1

;   None = 28
;   ReceiveAddress = None - 4 = 24
;   ReceiveData = None - 8 = 20
;   SendData = ReceiveData - 16 = 4

.program tpio
.side_set 5
                                             ; ENTRY
    pull block     side 28 ; P1 + None
    out pindirs,21 side 28 ; P1 + None       ; initialize Pin Dirs

    pull block     side 24 ; P1 + RecvAddr
    out pins,21    side 24 ; P1 + RecvAddr   ; initialize Pins

.wrap_target                                 ; BEGIN LOOP
top:
    nop             side 24 ; P1 + RecvAddr
    nop             side 24 ; P1 + RecvAddr        ; NEEDED?
    in  pins, 16    side 24 ; P1 + RecvAddr  ; Read Address
    nop             side 22 ; P2 + RecvData
    nop             side 22 ; P2 + RecvData        ; NEEDED?
    in  pins, 16    side 23 ;<- 22,23 ; P2 + RecvData  ; Read Data
    jmp pin, read   side 23 ; P3 + RecvData

; CPU write PICO rx                          ; IF WRITE CYCLE (Receiving from CPU)
    in pins, 16     side 21 ; P4 + RecvData    ; Receive accurate data.
    jmp top         side 24 ; P1 + RecvAddr

read:                                        ; ELSE READ CYCLE (Sending to CPU)
    pull block      side 21 ; P4 + RecvData
    out pindirs,16  side 21 ; P4 + RecvData  ; change Data Pins to output
    pull block      side 5 ;  P4 + SendData
    out pins,16     side 5 ;  P4 + SendData  ; output the data.
    pull block      side 4 ;  P1 + SendData  ; Drop E (P4->P1) but continue to output data.
    out pindirs,16  side 24 ; P1 + RecvAddr  ; change Data Pins to inputs
.wrap                                        ; REPEAT LOOP

% c-sdk {

// CLOCK DIVISOR: 16.0 was very reliable.  Stops getting faster at 8.  Breaks at 4.
// 16 -> 30.5; 14 -> 28.2; 12 -> 26.2; 10 -> 24.2; 8,6,5 -> 22.5; 4 -> Broke.
//        ( constant pre-roll overhead about 6 sec )

#define CLOCK_DIVISOR 4.0 // 6.0

void tpio_program_init(PIO pio, uint sm, uint offset) {
   //
   //  pico-examples/pio/hub75/hub75.pio shows order of inits.
   //
   pio_sm_set_consecutive_pindirs(pio, sm, 0, 16, false/*in*/);
   pio_sm_set_consecutive_pindirs(pio, sm, 16, 5, true/*out*/);
   for (uint i = 0; i < 21; i++) {
       pio_gpio_init(pio, i);
   }

   pio_sm_config cf = tpio_program_get_default_config(offset);
   sm_config_set_jmp_pin(&cf, 8);
   sm_config_set_in_pins(&cf, 0);
   sm_config_set_out_pins(&cf, 0, 16);
   sm_config_set_sideset(&cf, 5, false, false);
   sm_config_set_sideset_pins(&cf, 16);
   sm_config_set_clkdiv(&cf, CLOCK_DIVISOR);

   // IN: Shift from left, do autopush
   const bool IN_SHIFT_RIGHT = false;
   const bool AUTOPUSH = true;
   const uint PUSH_THRESHOLD = 16;
   sm_config_set_in_shift(&cf, IN_SHIFT_RIGHT, AUTOPUSH, PUSH_THRESHOLD);

   // OUT: Shift to right, don't autopull, threshold 29
   const bool OUT_SHIFT_RIGHT = true;
   const bool AUTOPULL = false;
   const uint PULL_THRESHOLD = 29;
   sm_config_set_out_shift(&cf, OUT_SHIFT_RIGHT, AUTOPULL, PULL_THRESHOLD);

   pio_sm_init(pio, sm, offset, &cf);
   pio_sm_exec(pio, sm, offset);
   pio_sm_set_enabled(pio, sm, true);
}
%}
